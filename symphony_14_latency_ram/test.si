const INSTRUCTION_A_0 = 0
const INSTRUCTION_A_1 = 1
const INSTRUCTION_A_2 = 2
const INSTRUCTION_B_0 = 3
const INSTRUCTION_B_1 = 4
const INSTRUCTION_B_2 = 5

const STALL_COUNT = INSTRUCTION_B_2 + 1

const KEYBOARD = STALL_COUNT + 1
const CONSOLE = KEYBOARD + 1

const REGS = CONSOLE + 1

const COUNTER_3 = REGS + 8
const COUNTER_2 = COUNTER_3 + 1
const COUNTER_1 = COUNTER_2 + 1
const COUNTER_0 = COUNTER_1 + 1

const IO_1 = COUNTER_0 + 1
const IO_2 = IO_1 + 1

const FLUSH_0 = IO_2 + 1
const FLUSH_1 = FLUSH_0 + 1
const FLUSH_2 = FLUSH_1 + 1

const RAM_IN_PIPE = FLUSH_2 + 1
const RAM_WAS_BUSY = RAM_IN_PIPE + 1

const RAM_LOAD_REG = RAM_WAS_BUSY + 1
const RAM_LOAD_VALUE = RAM_LOAD_REG + 1

const RAM = RAM_LOAD_VALUE + 1



const OP_IO  = 0
const OP_ALU = 1
const OP_JMP = 2
const OP_RAM = 3

def timer(input: Bool, $scratch_space: [Int], index: Int) Bool {

    let time = scratch_space[index]
    _reg_alloc_use time

    scratch_space[index] = max(0, time - 1)
    
    if time >= 1 { return true }

    if input {

        scratch_space[index] = 2

    }
    
}

def instruction_to_str(instruction: Int) String {

    let mode            = (instruction >> 30)
    let opcode          = (instruction >> 24) & 0b1111
    let dest            = (instruction >> 20) & 0b111
    let a               = (instruction >> 16) & 0b111
    let b               = (instruction >> 8) & 0b111
    let immediate       = (instruction >> 28) & 1 != 0
    let immediate_value =  instruction & 0xffff

    var dest_str = ""

    switch dest
        0 { dest_str = "rz" }
        6 { dest_str = "sp" }
        7 { dest_str = "flags" }
        default { dest_str = "r" + str(dest) }


    var a_str = ""

    switch a
        0 { a_str = "rz" }
        6 { a_str = "sp" }
        7 { a_str = "flags" }
        default { a_str = "r" + str(a) }

    var b_str = ""

    if immediate {

        b_str = str(immediate_value)

    } else {

        switch b
            0 { b_str = "rz" }
            6 { b_str = "sp" }
            7 { b_str = "flags" }
            default { b_str = "r" + str(b) }

    }

    switch mode

        OP_IO {

            const NOP      = 0
            const IN       = 1
            const OUT      = 2
            const CONSOLE  = 3
            const TIME_0   = 4
            const TIME_1   = 5
            const TIME_2   = 6
            const TIME_3   = 7
            const COUNTER  = 8
            const KEYBOARD = 9

            switch opcode
                NOP      { return `nop (does nothing)` }
                IN       { return `in {dest_str}` }
                OUT      { return `out {b_str}` }
                CONSOLE  { return `console {b_str}` }
                TIME_0   { return `time_0 {dest_str}` }
                TIME_1   { return `time_1 {dest_str}` }
                TIME_2   { return `time_2 {dest_str}` }
                TIME_3   { return `time_3 {dest_str}` }
                COUNTER  { return `counter {dest_str}` }
                KEYBOARD { return `keyboard {dest_str}` }

        }

        OP_ALU {

            var opcode_str = ""

            switch opcode
                0 { opcode_str = "nand" }
                1 { opcode_str = "or"  }
                2 { opcode_str = "and" }
                3 { opcode_str = "nor" }
                4 { opcode_str = "add" }
                5 { opcode_str = "sub" }
                6 { opcode_str = "xor" }
                7 { opcode_str = "lsl" }
                8 { opcode_str = "lsr" }
                9 { return `cmp {a_str}, {b_str}` }

            return `{opcode_str} {dest_str}, {a_str}, {b_str}`

        }

        OP_JMP {

            switch opcode
                0b1000  { return `jmp {b_str}` }
                0b0001  { return `je {b_str}` }
                0b1001  { return `jne {b_str}` }

                0b0010  { return `jb {b_str}` }
                0b1010  { return `jae {b_str}` }
                0b0011  { return `jbe {b_str}` }
                0b1011  { return `ja {b_str}` }

                0b0100  { return `jl {b_str}` }
                0b1100  { return `jge {b_str}` }
                0b0101  { return `jle {b_str}` }
                0b1101  { return `jg {b_str}` }

        }

        OP_RAM {

            const LOAD  = 0
            const STORE = 1

            switch opcode
                LOAD  { return `load {dest_str}, [{b_str}]` }
                STORE { return `store [{b_str}], {a_str}` }

        }

}

def flag_result(a: Int, b: Int) Int {

    let equal = <Int> (a == b)
    let uless = <Int> (<U16> a < <U16> b) & 1
    let sless = <Int> (<S16> a < <S16> b) & 1

    return (sless << 2) | (uless << 1) | equal

}

def check_io(instruction: Int) Bool {

    let immediate       = ((instruction >> 28) & 1) == 1
    let dest            = ((instruction >> 20) & 0b111) == 0b111
    let a               = ((instruction >> 16) & 0b111) == 0b111
    let b_value         = ((instruction >>  8) & 0b111) == 0b111
    let b               = immediate ? false : b_value

    return dest || a || b

}

def hazard_data(instruction_0: Int, instruction_1: Int) Bool {

    let mode_a        = (instruction_0 >> 30)
    let dest_a        = (instruction_0 >> 20) & 0b111

    let mode_b        = (instruction_1 >> 30)
    let a             = (instruction_1 >> 16) & 0b111
    let b             = (instruction_1 >> 8) & 0b111
    let immediate     = (instruction_1 >> 28) & 1 != 0

    if mode_a == OP_JMP {

        return false

    }

    if mode_b != OP_ALU {

        return false

    }

    if dest_a != 0 {

        if dest_a == a {

            return false

        }

        if dest_a == b && !immediate {

            return false

        }

    }

    return true

}

def hazard_branch(instruction: Int, stall: Bool, $scratch_space: [Int]) Bool {

    let mode = (instruction >> 30)

    return mode == OP_ALU || !stall

}

def hazard_structural(instruction: Int, ram_ready: Bool, $scratch_space: [Int]) Bool {

    if ram_ready {

        scratch_space[RAM_IN_PIPE] = 0

    }

    let result = scratch_space[RAM_IN_PIPE] != 1
    _reg_alloc_use result

    let mode = (instruction >> 30)

    if mode == OP_RAM {

        scratch_space[RAM_IN_PIPE] = 1

    }

    return result

}

def retire_instruction(instruction: Int, $scratch_space: [Int], input: Int) Int {
    
    let mode            = (instruction >> 30)
    let opcode          = (instruction >> 24) & 0b1111
    let dest            = (instruction >> 20) & 0b111
    let a               = (instruction >> 16) & 0b111
    let b               = (instruction >> 8) & 0b111
    let immediate       = (instruction >> 28) & 1 != 0
    let immediate_value =  instruction & 0xffff

    scratch_space[REGS + 0] = 0

    let a_value = scratch_space[REGS + a]
    let b_value = immediate ? immediate_value : scratch_space[REGS + b]

    def flag_result(a: Int, b: Int) Int {

        let equal = <Int> (a == b)
        let uless = <Int> (<U16> a < <U16> b) & 1
        let sless = <Int> (<S16> a < <S16> b) & 1

        return (sless << 2) | (uless << 1) | equal

    }

    switch mode

        OP_IO {

            const NOP         = 0
            const IO_IN       = 1
            const IO_OUT      = 2
            const IO_KEYBOARD = 3
            const IO_TIME_0   = 4
            const IO_TIME_1   = 5
            const IO_TIME_2   = 6
            const IO_TIME_3   = 7
            const IO_COUNTER  = 8
            const IO_CONSOLE  = 9

            switch opcode
                IO_IN {

                    scratch_space[REGS + dest] = input

                }
                IO_OUT {

                    return b_value

                }
                IO_KEYBOARD {

                    scratch_space[REGS + dest] = scratch_space[KEYBOARD]

                }
                IO_TIME_0 {

                    scratch_space[REGS + dest] = get_last_time() & 0xffff

                }
                IO_TIME_1 {

                    scratch_space[REGS + dest] = (get_last_time() >> 16) & 0xffff

                }
                IO_TIME_2 {

                    scratch_space[REGS + dest] = (get_last_time() >> 32) & 0xffff

                }
                IO_TIME_3 {

                    scratch_space[REGS + dest] = (get_last_time() >> 48) & 0xffff

                }
                IO_CONSOLE {

                    scratch_space[CONSOLE] = b_value

                }
                IO_COUNTER {

                    scratch_space[REGS + dest] = scratch_space[COUNTER_0] - 4

                }

        }

        OP_ALU {

            var result = 0

            switch opcode
                0 {
                    result = ~(a_value & b_value)
                }
                1 {
                    result = a_value | b_value
                }
                2 { 
                    result = a_value & b_value
                }
                3 { 
                    result = ~(a_value | b_value)
                }
                4 { 
                    result = a_value + b_value
                }
                5 { 
                    result = a_value - b_value
                }
                6 { 
                    result = a_value ^ b_value
                }
                7 { 
                    result = a_value << b_value
                }
                8 { 
                    result = a_value >> b_value
                }
                9 { 
                    result = flag_result(a_value, b_value)
                }

            if dest < 8 {
            
                scratch_space[REGS + dest] = result & 0xffff
            
            }

        }

        OP_JMP {

            let flags   = a_value & 0b111
            let matched = (opcode & flags) > 0
            let met     = matched != ((opcode & 0b1000) > 0)

            if met {

                scratch_space[COUNTER_0] = b_value
                scratch_space[FLUSH_0] = 1

            }

        }

        OP_RAM {

            const LOAD  = 0
            const STORE = 1

            switch opcode
                LOAD {

                    var value = scratch_space[RAM + b_value] << 8 + scratch_space[RAM + b_value + 1]
                    //scratch_space[REGS + dest] = value

                    scratch_space[RAM_LOAD_REG] = dest
                    scratch_space[RAM_LOAD_VALUE] = value

                }
                STORE {

                    scratch_space[RAM + b_value + 1] = a_value & 0xff
                    scratch_space[RAM + b_value + 0] = a_value >> 8
                    scratch_space[RAM_LOAD_REG] = 0


                }

        }

    scratch_space[REGS + 0] = 0

    return Z_STATE

}


def get_input($scratch_space: [Int], tick: Int, $inputs: [Int]) {

    let result = random(0xff)
    inputs[0] = result

}

def check_output($scratch_space: [Int], tick: Int, inputs: [Int], outputs: [Int]) TestResult {

    // Update everything except counter

    scratch_space[COUNTER_3] = scratch_space[COUNTER_2]
    scratch_space[COUNTER_2] = scratch_space[COUNTER_1]
    scratch_space[COUNTER_1] = scratch_space[COUNTER_0]

    let output = get_program_output()

    scratch_space[INSTRUCTION_A_2] = scratch_space[INSTRUCTION_A_1]
    scratch_space[INSTRUCTION_A_1] = scratch_space[INSTRUCTION_A_0]
    scratch_space[INSTRUCTION_A_0] = output >> 32

    scratch_space[INSTRUCTION_B_2] = scratch_space[INSTRUCTION_B_1]
    scratch_space[INSTRUCTION_B_1] = scratch_space[INSTRUCTION_B_0]
    scratch_space[INSTRUCTION_B_0] = output & 0xffffffff

    scratch_space[FLUSH_2] = scratch_space[FLUSH_1] | scratch_space[FLUSH_0]
    scratch_space[FLUSH_1] = scratch_space[FLUSH_0]
    scratch_space[FLUSH_0] = 0

    scratch_space[IO_2] = scratch_space[IO_1]
    scratch_space[IO_1] = inputs[0]

    ui_set_text("instruction_a_0", instruction_to_str(scratch_space[INSTRUCTION_A_0]))
    ui_set_text("instruction_a_1", instruction_to_str(scratch_space[INSTRUCTION_A_1]))
    ui_set_text("instruction_a_2", instruction_to_str(scratch_space[INSTRUCTION_A_2]))

    ui_set_text("instruction_b_0", instruction_to_str(scratch_space[INSTRUCTION_B_0]))
    ui_set_text("instruction_b_1", instruction_to_str(scratch_space[INSTRUCTION_B_1]))
    ui_set_text("instruction_b_2", instruction_to_str(scratch_space[INSTRUCTION_B_2]))


    let instruction_a = scratch_space[INSTRUCTION_A_0]
    let instruction_b = scratch_space[INSTRUCTION_B_0]

    var ram_ready = scratch_space[RAM_WAS_BUSY] == 1 && !get_latency_ram_is_busy()
    _reg_alloc_use ram_ready
    scratch_space[RAM_WAS_BUSY] = get_latency_ram_is_busy()

    if ram_ready && scratch_space[RAM_LOAD_REG] != 0 {

        scratch_space[REGS + scratch_space[RAM_LOAD_REG]] = scratch_space[RAM_LOAD_VALUE]

    }

    let mispredicted = (scratch_space[FLUSH_2] == 1) && (scratch_space[FLUSH_1] == 1)

    let stall                = timer(instruction_a >> 30 == OP_JMP, $scratch_space, STALL_COUNT)
    let no_data_hazard       = hazard_data(instruction_a, instruction_b)
    let no_structural_hazard = hazard_structural(instruction_a, ram_ready || mispredicted, $scratch_space)

    let enable_a = no_structural_hazard
    let enable_b = no_data_hazard && no_structural_hazard

    if enable_a {

        scratch_space[COUNTER_0] = (scratch_space[COUNTER_0] + 4) & 0xffff

    } else {

        scratch_space[INSTRUCTION_A_0] = 0

    }

    if enable_b {

        scratch_space[COUNTER_0] = (scratch_space[COUNTER_0] + 4) & 0xffff

    } else {

        scratch_space[INSTRUCTION_B_0] = 0

    }

    if scratch_space[FLUSH_2] == 1 {

        scratch_space[INSTRUCTION_A_2] = 0
        scratch_space[INSTRUCTION_B_2] = 0

    }


    // Retire instructions

    let correct_output = retire_instruction(scratch_space[INSTRUCTION_A_2], $scratch_space, inputs[0])
    retire_instruction(scratch_space[INSTRUCTION_B_2], $scratch_space, 0)

    if correct_output != Z_STATE && outputs[1] != correct_output {

        set_error(`Output should be {correct_output}.`)
        return fail

    }

    var reg = 1
    while reg < 8 {

        let value = get_register_value(reg - 1)

        if value != scratch_space[REGS + reg] {

            var register = ""
            switch reg
                6 { register = "'sp'" }
                7 { register = "'flags'" }
                default { register = `r{reg}`}

            set_error(`{register} should have value {scratch_space[REGS + reg]}, not {value}`)
            return fail

        }

        reg += 1

    }

    if get_ram_size() != 65536 {

        set_error(`Set RAM size to 65536.`)
        return fail

    }

    var addr = 0
    while addr < 0xfffe {

        let value = get_ram_value(addr)

        if value != scratch_space[RAM + addr] {

            set_error(`RAM should contain value {scratch_space[RAM + addr]}, at address {addr}, not {value}.`)
            return fail

        }

        addr += 1

    }

    // Check pipeline values, (do this after updating registers)

    const INSTR_A  = 0
    const MODE_A   = 1
    const OPCODE_A = 2
    const DEST_A   = 3
    const ARG_A_1  = 4
    const ARG_B_1  = 5
    const COUNTER  = 6
    const INSTR_B  = 7
    const MODE_B   = 8
    const OPCODE_B = 9
    const DEST_B   = 10
    const ARG_A_2  = 11
    const ARG_B_2  = 12

    {

        const IO = REGS + 7
        let dest = (scratch_space[INSTRUCTION_A_2] >> 20) & 0b111

        if dest == IO {

            if outputs[2] & 1 != 1 {
                set_error(`Output should be enabled`)
                return fail
            }

            if outputs[1] != scratch_space[IO] {
                set_error(`Output should be {scratch_space[IO]}`)
                return fail
            }

        }

        if scratch_space[INSTRUCTION_A_0] != get_level_memory("INSTR") {

            set_error(`The "INSTR" delay line should contain the last instruction: {scratch_space[INSTRUCTION_A_0]}.`)
            return fail

        }

        if scratch_space[INSTRUCTION_B_0] != get_level_memory("INSTR 2") {

            if scratch_space[INSTRUCTION_B_0] == 0 {

                set_error(`The second instruction should be disabled, so "INSTR 2" should contain 0.`)

            } else {
            
                set_error(`The "INSTR 2" delay line should contain the last instruction: {scratch_space[INSTRUCTION_B_0]}.`)

            }

            return fail

        }

    }

    {

        {

            if scratch_space[COUNTER_1] != get_level_memory("COUNTER 1") {

                set_error(`The "COUNTER 1" delay line should contain value {scratch_space[COUNTER_1]}, not {get_level_memory("COUNTER 1")}.`)
                return fail

            }

            let instruction = scratch_space[INSTRUCTION_A_1]

            let mode            = (instruction >> 30)
            let opcode          = (instruction >> 24) & 0b1111
            let dest            = (instruction >> 20) & 0b111
            let a               = (instruction >> 16) & 0b111
            let b               = (instruction >> 8)  & 0b111
            let immediate       = (instruction >> 28) & 1 != 0
            let immediate_value =  instruction & 0xffff

            let a_value = scratch_space[REGS + a]
            let b_value = immediate ? immediate_value : scratch_space[REGS + b]

            if mode != get_level_memory("MODE") {

                set_error(`The "MODE A" delay line should contain value {mode}, not {get_level_memory("MODE")}`)
                return fail

            }

            if opcode != get_level_memory("OPCODE") {

                set_error(`The "OPCODE A" delay line should contain value {opcode}, not {get_level_memory("OPCODE")}`)
                return fail

            }

            if dest != get_level_memory("DEST") {

                set_error(`The "DEST" delay line should contain value {dest}, not {get_level_memory("DEST_A")}`)
                return fail

            }

            if a_value != get_level_memory("ARG_A") {

                set_error(`The "ARG_A" delay line should contain value {a_value & 0xffff}, not {get_level_memory("ARG_A")}`)
                return fail

            }

            if b_value != get_level_memory("ARG_B") {

                set_error(`The "ARG_B" delay line should contain value {b_value & 0xffff}, not {get_level_memory("ARG_B")}`)
                return fail

            }

        }

        {

            let instruction = scratch_space[INSTRUCTION_B_1]

            let mode            = (instruction >> 30)
            let opcode          = (instruction >> 24) & 0b1111
            let dest            = (instruction >> 20) & 0b111
            let a               = (instruction >> 16) & 0b111
            let b               = (instruction >> 8)  & 0b111
            let immediate       = (instruction >> 28) & 1 != 0
            let immediate_value =  instruction & 0xffff

            let a_value = scratch_space[REGS + a]
            let b_value = immediate ? immediate_value : scratch_space[REGS + b]

            if dest != get_level_memory("DEST 2") {

                set_error(`The "DEST B" delay line should contain value {dest}, not {get_level_memory("DEST 2")}`)
                return fail

            }

            if a_value != get_level_memory("ARG_A 2") {

                set_error(`The "ARG_A 2" delay line should contain value {a_value & 0xffff}, not {get_level_memory("ARG_A 2")}`)
                return fail

            }

            if b_value != get_level_memory("ARG_B 2") {

                set_error(`The "ARG_B 2" delay line should contain value {b_value & 0xffff}, not {get_level_memory("ARG_B 2")}`)
                return fail

            }

        }

    }

    if tick == 2000 {

        if get_delay_score() >= 60 {

            set_error(`Your solution is correct, but delay should be less than 60.`)
            return fail

        }

        return win

    }

}
